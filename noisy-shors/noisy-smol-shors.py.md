# `noisy-smol-shors.py`

```python
# from the paper 'How to factor 2048 bit RSA integers with less than a million noisy qubits'
# generated by https://g.co/gemini/share/b023cdf4bcad
#

import math
import random
from fractions import Fraction

# Conditional import for PyQrack
try:
    from pyqrack import qrack_system
    PYQRACK_AVAILABLE = True
except ImportError:
    PYQRACK_AVAILABLE = False
    print("Warning: PyQrack not found. Quantum steps will be illustrative only or skipped.")

# --- Classical Helper Functions ---
def gcd(a, b):
    """Compute the greatest common divisor of a and b."""
    while b:
        a, b = b, a % b
    return a

# --- Quantum Oracle and Period Finding Components ---

def controlled_modular_multiplier_permutation(qsim, control_qubit, target_qubits, factor, N):
    """
    Applies controlled operation: if control_qubit is 1, then y -> (y * factor) mod N.
    target_qubits: list of qubit indices for y (LSB is target_qubits[0]).
    factor: the classical integer to multiply by.
    N: the modulus.

    This function implements the permutation by applying controlled-X gates
    for each input state of the target register that needs to be changed.
    """
    num_target_qubits = len(target_qubits)

    # Iterate over all possible input states 's_in' of the target register that are less than N
    for s_in in range(N):
        s_out = (s_in * factor) % N

        if s_in == s_out:  # If this state maps to itself, no operation needed for it
            continue

        # op_controls will store all qubits that need to be 1 for this specific transformation
        op_controls = [control_qubit]

        # Temporary X gates to set target_qubits to match the s_in pattern
        # These ensure the mcx acts only when target_qubits are in state |s_in>
        temp_x_gates_applied_to_target = []
        for i in range(num_target_qubits):
            qubit_idx = target_qubits[i]  # LSB
            if not ((s_in >> i) & 1):  # If i-th bit of s_in is 0, flip it to 1 for control
                qsim.x(qubit_idx)
                temp_x_gates_applied_to_target.append(qubit_idx)
            op_controls.append(qubit_idx)

        # Determine the bits to flip in the target register to go from s_in to s_out
        xor_mask = s_in ^ s_out
        for i in range(num_target_qubits):
            if (xor_mask >> i) & 1:  # If the i-th bit needs to be flipped
                target_flip_qubit_idx = target_qubits[i]
                qsim.mcx(op_controls, target_flip_qubit_idx) # Multi-Controlled X

        # Undo the temporary X gates on target_qubits (in reverse order)
        for qubit_idx in reversed(temp_x_gates_applied_to_target):
            qsim.x(qubit_idx)

def controlled_modular_exponentiation(qsim, control_register_indices, target_register_indices, base_a, N):
    """
    Computes |x>|y> -> |x>|y * base_a^x mod N>
    control_register_indices: list of qubit indices for x (LSB is control_register_indices[0]).
    target_register_indices: list of qubit indices for y (LSB is target_register_indices[0]).
    base_a: the classical base for the exponentiation.
    N: the modulus.
    Assumes target_register is initialized appropriately (e.g., to |1> for |a^x mod N>).
    """
    for i, c_qubit_idx in enumerate(control_register_indices):
        # The power for this control qubit is base_a^(2^i)
        current_power_val = pow(base_a, 1 << i, N)

        # Optimization: if current_power_val is 1, multiplying by it does nothing (for N>2).
        if current_power_val == 1 and N > 2 :
            # print(f"  (Skipping c-mult by {current_power_val} for control q[{c_qubit_idx}])")
            continue # Skip to the next control qubit

        # print(f"  Applying c-mult by {current_power_val} (mod {N}), controlled by q[{c_qubit_idx}]")
        controlled_modular_multiplier_permutation(qsim,
                                                  c_qubit_idx,
                                                  target_register_indices,
                                                  current_power_val,
                                                  N)

def qft_dagger(qsim, qubit_indices):
    """Inverse Quantum Fourier Transform on the specified qubits."""
    # PyQrack provides iqft_permutation for this.
    # Ensure qubit_indices is a list of integers.
    qsim.iqft_permutation([int(q) for q in qubit_indices])


def quantum_period_finding_subroutine(qsim, num_control_qubits, num_target_qubits, base_a, N):
    """
    Performs the quantum part of Shor's algorithm to find a value related to the period.
    Returns the measured integer from the control register.
    """
    # Define qubit registers (indices)
    # Control register for phase estimation (stores 'x')
    control_register = list(range(num_control_qubits))
    # Target register for modular exponentiation (stores 'y' or 'a^x mod N')
    target_register = list(range(num_control_qubits, num_control_qubits + num_target_qubits))

    # 1. Initialize control qubits to superposition: H gates
    # print("  Initializing control register to superposition...")
    for q_idx in control_register:
        qsim.h(q_idx)

    # 2. Initialize target register to state |1>
    # To represent |1>, set the LSB (target_register[0]) to 1, others to 0.
    # print("  Initializing target register to |1>...")
    qsim.x(target_register[0])

    # 3. Apply controlled modular exponentiation
    # print(f"  Applying controlled modular exponentiation: a={base_a}, N={N}...")
    controlled_modular_exponentiation(qsim, control_register, target_register, base_a, N)

    # 4. Apply inverse QFT to the control register
    # print("  Applying Inverse QFT to control register...")
    qft_dagger(qsim, control_register)

    # 5. Measure the control register
    # print("  Measuring control register...")
    measured_value_int = 0
    for i, q_idx in enumerate(control_register): # LSB first for measurement
        if qsim.m(q_idx): # qsim.m() returns True if outcome is 1
            measured_value_int |= (1 << i)

    return measured_value_int

# --- Shor's Algorithm Main Classical Logic ---
def shor_factor_pyqrack(N_to_factor, num_classical_trials=10, fixed_a=None):
    """
    Attempts to factor N_to_factor using Shor's algorithm simulated by PyQrack.
    """
    if not PYQRACK_AVAILABLE:
        print(f"Factoring {N_to_factor} classically (PyQrack not available for quantum steps).")
        # Basic classical factorization for small N if PyQrack is missing
        for i in range(2, int(math.sqrt(N_to_factor)) + 1):
            if N_to_factor % i == 0:
                print(f"  Classical factors found: {i}, {N_to_factor//i}")
                return i, N_to_factor//i
        print(f"  {N_to_factor} is prime or classical factoring failed.")
        return None, None

    print(f"Attempting to factor N = {N_to_factor} using Shor's algorithm (simulated with PyQrack)")

    if N_to_factor <= 1:
        print("  Number must be greater than 1.")
        return None, None
    if N_to_factor % 2 == 0:
        print(f"  Factor found (trivial): 2, {N_to_factor//2}")
        return 2, N_to_factor//2

    # Determine number of qubits
    # n_bits_N is the number of bits to represent N (also for the target register)
    n_bits_N = N_to_factor.bit_length()

    # t_control_qubits for the control register (phase estimation precision)
    # Needs to be large enough for good resolution, e.g., 2*n_bits_N.
    # For N=15, n_bits_N=4. t_control_qubits=8 gives good peaks.
    # Let's use a minimum of 5 for demonstration, and scale up to 2*n_bits_N.
    t_control_qubits = max(5, 2 * n_bits_N)

    m_target_qubits = n_bits_N # Target register size

    total_qubits_needed = t_control_qubits + m_target_qubits
    print(f"  Using {t_control_qubits} control qubits, {m_target_qubits} target qubits. Total: {total_qubits_needed} qubits.")

    for trial_num in range(num_classical_trials):
        # Step 1: Pick a random number 'a' < N
        if fixed_a and trial_num == 0 : # Allow fixing 'a' for first trial for debugging/testing
            a = fixed_a
            if gcd(a, N_to_factor) != 1:
                print(f"  Fixed 'a'={a} is not coprime to N. Choose another or let it be random.")
                a = random.randint(2, N_to_factor - 1)
        else:
            a = random.randint(2, N_to_factor - 1)

        print(f"\nTrial {trial_num + 1}/{num_classical_trials}: Choosing a = {a}")

        # Step 2: Check if gcd(a, N) > 1 (lucky classical find)
        common_divisor = gcd(a, N_to_factor)
        if common_divisor > 1:
            print(f"  Lucky classical find: gcd({a}, {N_to_factor}) = {common_divisor}")
            return common_divisor, N_to_factor // common_divisor

        # Step 3: Quantum Period Finding
        qsim = qrack_system.QrackSimulator(total_qubits_needed)

        measured_s = quantum_period_finding_subroutine(qsim, t_control_qubits, m_target_qubits, a, N_to_factor)
        print(f"  Measured integer from control register (s): {measured_s}")

        del qsim # Release Qrack simulator resources for this run

        if measured_s == 0:
            print("  Measured s=0 (phase is 0). Period finding failed for this 'a'. Retrying with new 'a'.")
            continue

        # Step 4: Classical post-processing (Continued Fractions)
        # We are looking for period 'r' such that measured_s / (2^t_control_qubits) is close to k / r
        phase_numerator = measured_s
        phase_denominator = 1 << t_control_qubits # 2^t_control_qubits
        print(f"  Phase approximation: {phase_numerator}/{phase_denominator} = {phase_numerator/phase_denominator:.5f}")

        # Use continued fractions to find r (the period)
        # Limit denominator to N_to_factor, as r < N_to_factor
        frac = Fraction(phase_numerator, phase_denominator).limit_denominator(N_to_factor)
        r = frac.denominator
        print(f"  Continued fraction result: {frac.numerator}/{frac.denominator}. Deduced period r = {r}")

        if r == 0 : # Should not happen if measured_s != 0
            print("  Deduced period r=0. Error in post-processing or measurement. Retrying.")
            continue
        if r % 2 != 0: # Period 'r' must be even
            print(f"  Period r={r} is odd. Need an even period. Retrying with new 'a'.")
            continue

        # Step 5: Check if r gives non-trivial factors
        # Calculate x = a^(r/2) mod N
        # Python's pow(base, exp, mod) is efficient for modular exponentiation
        term1 = pow(a, r // 2, N_to_factor)

        if (term1 + 1) % N_to_factor == 0: # x = -1 (mod N)
            print(f"  x = a^(r/2) = -1 (mod N). Period r={r} gives trivial factors. Retrying with new 'a'.")
            continue
        if (term1 - 1) % N_to_factor == 0: # x = 1 (mod N)
             print(f"  x = a^(r/2) = 1 (mod N). Period r={r} might be too small or 'a' was a bad choice. Retrying.")
             continue


        factor1 = gcd(term1 - 1, N_to_factor)
        factor2 = gcd(term1 + 1, N_to_factor)

        # found_non_trivial = False # This variable was unused
        if factor1 != 1 and factor1 != N_to_factor:
            print(f"  Factor found: {factor1}")
            print(f"  Factors are: {factor1}, {N_to_factor // factor1}")
            return factor1, N_to_factor // factor1

        if factor2 != 1 and factor2 != N_to_factor: # factor1 might have been trivial
            print(f"  Factor found: {factor2}")
            print(f"  Factors are: {factor2}, {N_to_factor // factor2}")
            return factor2, N_to_factor // factor2

        print(f"  Period r={r} did not yield non-trivial factors with a={a}. Retrying with new 'a'.")

    print(f"\nShor's algorithm failed to find factors for {N_to_factor} after {num_classical_trials} trials.")
    return None, None

if __name__ == "__main__":
    N_to_factor = 15  # Standard small example for Shor's
    # N_to_factor = 21 # Another small example
    # N_to_factor = 35 # Getting larger

    if not PYQRACK_AVAILABLE:
        print("PyQrack is required for the quantum simulation parts of this script.")
        print("Please install it (e.g., 'pip install pyqrack') to run the full example.")
        print("Attempting classical factorization for demonstration purposes...")

    # You can try a fixed 'a' for N=15 that is known to work well, e.g., a=7 or a=11 for testing.
    # For N=15, a=7, r=4.
    # For N=15, a=11, r=2.
    # For N=15, a=13, r=4.
    # For N=15, a=4, r=2. (gcd(4,15)=1)

    # result_factors = shor_factor_pyqrack(N_to_factor, fixed_a=7)
    result_factors = shor_factor_pyqrack(N_to_factor)


    if result_factors and result_factors[0] is not None:
        print(f"\nSuccessfully factored {N_to_factor} into: {result_factors[0]} and {result_factors[1]}")
    else:
        print(f"\nCould not factor {N_to_factor} with the given attempts using the quantum routine.")

#
# **To Run This Code:**
#
# 1.  **Install PyQrack:** If you haven't already, install PyQrack:
#     ```bash
#     pip install pyqrack
#     ```
# 2.  **Save the code:** Save the script above as a Python file (e.g., `shor_pyqrack_demo.py`).
# 3.  **Run from terminal:**
#     ```bash
#     python shor_pyqrack_demo.py
#     ```
#
# **Explanation and What to Expect:**
#
# * **Classical Framework:** The script sets up the classical parts of Shor's algorithm: choosing `a`,
#   checking for lucky GCDs, and classical post-processing using continued fractions to find the period `r`.
# * **Quantum Subroutine (`quantum_period_finding_subroutine`):**
#     * Initializes control qubits in superposition (Hadamard gates).
#     * Initializes the target register to `|1>`.
#     * Calls `controlled_modular_exponentiation`. This is the most complex quantum part.
#         * `controlled_modular_exponentiation` iterates through each control qubit. For the `i`-th control qubit,
#           it calculates `power = base_a^(2^i) mod N`.
#         * It then calls `controlled_modular_multiplier_permutation` to apply the operation: if the `i`-th
#           control qubit is `|1>`, multiply the target register by `power` (mod N).
#         * `controlled_modular_multiplier_permutation` is implemented by defining the classical permutation
#           `y -> (y * power) % N` and then, for each input state `s_in` of the target register, applying a
#           series of multi-controlled X gates (Toffolis) to transform `|s_in>` to `|s_out>` if the main
#           control qubit (from the control register) is active and the target register is indeed in state `|s_in>`.
#           This is a direct but potentially gate-intensive way to implement controlled permutations.
#     * Applies an inverse Quantum Fourier Transform (IQFT) to the control register using PyQrack's `iqft_permutation`.
#     * Measures the control register to get an integer `s`.
# * **Post-Processing:** The classical part then uses `s` and the number of control qubits to estimate
#   the period `r` via continued fractions.
# * **Factoring:** If a suitable `r` is found, it attempts to calculate the factors of `N`.
# * **Simulation Time:** Even for N=15, the simulation can be slow because the
#   `controlled_modular_multiplier_permutation` involves many conditional operations that translate to
#   numerous (multi-controlled) gates being simulated. The number of qubits will be relatively small
#   (e.g., for N=15, around 8 control + 4 target = 12 qubits, which PyQrack handles fine),
#   but the gate depth for the arithmetic can be large.
# * **Success Probability:** Shor's algorithm is probabilistic. You might need multiple classical trials
#   (different choices of `a`) to find the factors. The number of control qubits also affects the
#   probability of measuring a "good" `s` that leads to the correct period `r`.
#
# This script provides a foundational example. Building more optimized quantum arithmetic circuits
# (like those based on QFT adders or more advanced constructions) would be the next step for
# larger numbers but significantly increases implementation complexity.
#
```
