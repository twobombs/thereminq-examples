#!/usr/bin/env python3

# graph for the output of otoc_validation_isingonly.sh
# generated by gemini25
#
# MODIFIED:
# - Now uses `multiprocessing.Pool` to parse log files in parallel
#   using all available CPU cores.
# - Added `tqdm` for a progress bar during parsing.

import re
import ast
import pandas as pd
from vedo import Points, Plotter, settings
from pathlib import Path
import math
import os
from multiprocessing import Pool
from tqdm import tqdm

# --- Configuration ---
LOG_DIR = "otoc_sweep_log"
OUTPUT_FILE = "otoc_sweep_3d_plot.png"
# --- End Configuration ---

def parse_log_file(file_path: Path) -> dict | None:
    """
    Parses a single log file to find qubits, depth, 
    log(real time), and the probability of the *highest*
    measured outcome.
    
    (This function is unchanged and is what each core will run)
    """
    # 1. Parse filename for qubits and depth
    match = re.search(r"q(\d+)_d(\d+)\.log", file_path.name)
    if not match:
        return None
    
    qubits = int(match.group(1))
    depth = int(match.group(2))
    
    try:
        content = file_path.read_text()
        
        # --- 2. Parse for 'real' time (for Z-axis) ---
        time_match = re.search(r"real\s+(\d+)m([\d\.]+)s", content)
        if not time_match:
            print(f"Warning: Could not find 'real' time string in {file_path.name}")
            return None
            
        try:
            minutes = float(time_match.group(1))
            seconds = float(time_match.group(2))
            total_seconds = (minutes * 60) + seconds
        except (ValueError, TypeError) as e:
            print(f"Error converting time string in {file_path.name}: {e}")
            return None

        if total_seconds <= 0:
            print(f"Warning: Non-positive time {total_seconds}s in {file_path.name}")
            return None
        
        log_time = math.log(total_seconds)
            
        # --- 3. Parse for 'max_outcome_prob' (for Color) ---
        dict_match = re.search(r"PyQrackIsing Results:\s*(\{.*\})", content, re.DOTALL)
        if not dict_match:
            print(f"Warning: Could not find results dict in {file_path.name}")
            return None
            
        results_dict = ast.literal_eval(dict_match.group(1))
        
        if not results_dict:
            print(f"Warning: Results dictionary is empty in {file_path.name}")
            return None

        try:
            # Find the highest key (which represents the highest node number/outcome)
            max_outcome_key = max(results_dict.keys())
        except Exception as e:
            print(f"Warning: Could not find max key in results dict for {file_path.name}: {e}")
            return None
            
        # Get the probability for that highest key.
        target_prob = results_dict.get(max_outcome_key)
        
        if target_prob is None:
            print(f"Warning: Could not find value for max key {max_outcome_key} in {file_path.name}")
            return None
            
        try:
            target_prob = float(target_prob)
        except (ValueError, TypeError):
            print(f"Warning: 'target_prob' value {target_prob} is not a float in {file_path.name}")
            return None

        # --- 4. Return all data ---
        return {
            "qubits": qubits, 
            "depth": depth, 
            "log_time": log_time, 
            "max_outcome_prob": target_prob
        }
        
    except Exception as e:
        print(f"Error parsing {file_path.name}: {e}")
        return None

def main():
    log_path = Path(LOG_DIR)
    if not log_path.is_dir():
        print(f"Error: Log directory '{LOG_DIR}' not found.")
        print("Please run this script in the same folder as your 'otoc_sweep_log' directory.")
        return

    print(f"Scanning {LOG_DIR} for log files...")
    
    log_files = list(log_path.glob("q*_d*.log"))
    
    if not log_files:
        print(f"Error: No log files found in '{LOG_DIR}'.")
        return

    # --- MODIFIED: Parallel Processing ---
    num_cores = os.cpu_count() or 1 # Get available cores, default to 1
    print(f"Found {len(log_files)} log files. Parsing in parallel using {num_cores} cores...")
    
    data = []
    # Use a context manager for the Pool
    with Pool(processes=num_cores) as pool:
        # Use tqdm to wrap the iterator for a progress bar
        # pool.imap_unordered is fast because it processes jobs as they come
        results_iterator = pool.imap_unordered(parse_log_file, log_files)
        
        # 'total=len(log_files)' tells tqdm the total number of items
        for parsed_data in tqdm(results_iterator, total=len(log_files), desc="Parsing Files"):
            if parsed_data:
                data.append(parsed_data)
    # --- END MODIFICATION ---
            
    if not data:
        print("Error: No data could be parsed from log files.")
        return
        
    print(f"Successfully parsed {len(data)} log files.")

    # 3. Create Pandas DataFrame
    df = pd.DataFrame(data)
    df = df.sort_values(by=["qubits", "depth"])

    print("Generating 3D interactive plot...")

    # --- Vedo Plotting Logic (Unchanged) ---
    coords = df[['qubits', 'depth', 'log_time']].values
    scalars = df['max_outcome_prob'].values
    
    pts = Points(coords, r=8)
    
    pts.pointdata["max_outcome_prob"] = scalars
    pts.cmap("viridis", "max_outcome_prob")  
    
    pts.add_scalarbar(
        title="Probability of Max Outcome",
        pos=((0.85, 0.1), (0.9, 0.9)), 
        c='white'
    ) 

    plt = Plotter(
        title="OTOC Sweep: Log(Time) vs. Qubits and Depth", 
        bg='black',
        axes={
            'xtitle': 'Number of Qubits',
            'ytitle': 'Depth',
            'ztitle': 'Log(Execution Time)',
            'c': 'white'
        }
    )

    plt.add(pts)

    try:
        print(f"Attempting to save screenshot to: {OUTPUT_FILE}...")
        plt.screenshot(OUTPUT_FILE)
        print(f"Successfully saved screenshot to: {OUTPUT_FILE}")
    except Exception as e:
        print(f"Could not save screenshot: {e}")

    print("Displaying plot in separate window...")
    plt.show()
    
    print("Done.")

# This __name__ check is CRITICAL for multiprocessing
if __name__ == "__main__":
    main()
