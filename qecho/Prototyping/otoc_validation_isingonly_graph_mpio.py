# graph for the output of otoc_validation_isingonly.sh
# generated by gemini25
# Fix applied to handle missing '0' key (prob_zero defaults to 0.0)
# Multiprocessing added to bypass the GIL for CPU-bound parsing
# Memory fix: File is now read line-by-line
# Parser fix: Handles dictionary starting on a new line after the header
# FINAL MEMORY FIX: Parser now scans for '0:' key and avoids ast.literal_eval

import re
import ast
import pandas as pd
from vedo import Points, Plotter, settings
from pathlib import Path
import math
import concurrent.futures  # For ProcessPoolExecutor
import os                  # To get CPU count

# --- Configuration ---
LOG_DIR = "otoc_sweep_log"
OUTPUT_FILE = "otoc_sweep_3d_plot.png"
# --- End Configuration ---

def parse_log_file(file_path):
    """
    Parses a single log file line-by-line to find qubits, depth, 
    log(real time), and prob_zero.
    
    *** MEMORY FIX v2 ***
    This version does NOT load the dictionary into memory.
    It scans for the '0:' key directly in the file stream.
    """
    # 1. Parse filename for qubits and depth (no change)
    match = re.search(r"q(\d+)_d(\d+)\.log", file_path.name)
    if not match:
        return None
    
    qubits = int(match.group(1))
    depth = int(match.group(2))
    
    time_match = None
    prob_zero = None # We will search for this
    
    # State Machine Variables
    found_header = False 
    in_dict = False      
    brace_level = 0
    
    # This regex looks for a word boundary, the key '0', a colon,
    # and then captures the floating point number (including scientific notation).
    # \b0: avoids matching a key like '1230:'
    prob_regex = re.compile(r"\b0:\s*([\d\.eE+-]+)")

    try:
        with file_path.open('r') as f:
            for line in f:
                
                # --- 1. Parse for 'real' time (for Z-axis) ---
                time_search = re.search(r"real\s+(\d+)m([\d\.]+)s", line)
                if time_search:
                    time_match = time_search
                
                # --- 2. State Machine for Dictionary Parsing ---
                
                if not found_header:
                    if "PyQrackIsing Probabilities:" in line:
                        found_header = True
                        start_match = re.search(r"(\{)", line)
                        if start_match:
                            in_dict = True
                            brace_level += line.count('{') - line.count('}')
                            # Check for prob_zero on this same line
                            if prob_zero is None:
                                prob_match = prob_regex.search(line)
                                if prob_match:
                                    prob_zero = float(prob_match.group(1))
                
                elif found_header and not in_dict:
                    start_match = re.search(r"(\{)", line)
                    if start_match:
                        in_dict = True
                        brace_level += line.count('{') - line.count('}')
                        # Check for prob_zero on this first line
                        if prob_zero is None:
                            prob_match = prob_regex.search(line)
                            if prob_match:
                                prob_zero = float(prob_match.group(1))
                
                elif in_dict:
                    # We are in the middle of reading the dictionary
                    
                    # *** KEY CHANGE: ***
                    # Only search for prob_zero if we haven't found it yet.
                    if prob_zero is None:
                        prob_match = prob_regex.search(line)
                        if prob_match:
                            prob_zero = float(prob_match.group(1))
                            # We found it! We can't stop (still need 'real' time),
                            # but we can stop searching for this regex.

                    # We still *must* track braces to know when the dict ends,
                    # in case '0' is not present.
                    brace_level += line.count('{') - line.count('}')
                    if brace_level == 0:
                        in_dict = False # Exit STATE 2

                        
        # --- End of file read, now process the captured data ---

        # Process Time
        if not time_match:
            print(f"Warning: Could not find 'real' time string in {file_path.name}")
            return None
        try:
            minutes = float(time_match.group(1))
            seconds = float(time_match.group(2))
            total_seconds = (minutes * 60) + seconds
        except (ValueError, TypeError) as e:
            print(f"Error converting time string in {file_path.name}: {e}")
            return None

        if total_seconds <= 0:
            print(f"Warning: Non-positive time {total_seconds}s in {file_path.name}")
            return None
        log_time = math.log(total_seconds)
            
        # Process Dictionary
        if in_dict:
            print(f"Warning: Reached EOF, but dict was still open in {file_path.name}")
            
        if not found_header:
            print(f"Warning: Could not find results dict header in {file_path.name}")
            return None

        # If we scanned the whole dictionary and never found the key '0'
        if prob_zero is None:
            # This is the "missing key" fix from the original script
            print(f"Warning: Key '0' not found in {file_path.name}. Defaulting to 0.0")
            prob_zero = 0.0

        # --- 4. Return all data ---
        return {
            "qubits": qubits, 
            "depth": depth, 
            "log_time": log_time, 
            "prob_zero": prob_zero
        }
        
    except Exception as e:
        print(f"Error processing {file_path.name}: {e}")
        return None


def main():
    # This function is unchanged
    log_path = Path(LOG_DIR)
    if not log_path.is_dir():
        print(f"Error: Log directory '{LOG_DIR}' not found.")
        print("Please run this script in the same folder as your 'otoc_sweep_log' directory.")
        return

    print(f"Scanning {LOG_DIR} for log files...")
    
    log_files = list(log_path.glob("q*_d*.log"))
    
    if not log_files:
        print(f"Error: No log files found in '{LOG_DIR}'.")
        return

    # --- Multiprocessing Enhancement ---
    num_workers = os.cpu_count()
    print(f"Parsing {len(log_files)} log files using up to {num_workers} processes...")
    
    data = []
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:
        results_iterator = executor.map(parse_log_file, log_files)
        data = [result for result in results_iterator if result is not None]
    # --- End Multiprocessing ---
        
    if not data:
        print("Error: No data could be parsed from log files.")
        return
        
    print(f"Successfully parsed {len(data)} log files.")

    # 3. Create Pandas DataFrame
    df = pd.DataFrame(data)
    df = df.sort_values(by=["qubits", "depth"])

    print("Generating 3D interactive plot...")

    # --- Vedo Plotting Logic (unchanged) ---
    coords = df[['qubits', 'depth', 'log_time']].values
    scalars = df['prob_zero'].values

    pts = Points(coords, r=8)
    
    pts.pointdata["prob_zero"] = scalars
    pts.cmap("viridis", "prob_zero") 
    
    pts.add_scalarbar(title="Probability of '0' State", pos=((0.85, 0.1), (0.9, 0.9)), c='white') 

    plt = Plotter(
        title="OTOC Sweep: Log(Time) vs. Qubits and Depth", 
        bg='black',
        axes={
            'xtitle': 'Number of Qubits',
            'ytitle': 'Depth',
            'ztitle': 'Log(Execution Time)',
            'c': 'white'
        }
    )

    plt.add(pts)

    # 7. Save to PNG
    try:
        print(f"Attempting to save screenshot to: {OUTPUT_FILE}...")
        plt.screenshot(OUTPUT_FILE)
        print(f"Successfully saved screenshot to: {OUTPUT_FILE}")
    except Exception as e:
        print(f"Could not save screenshot: {e}")

    # 8. Show the interactive window
    print("Displaying plot in separate window...")
    plt.show() # This opens a native window
    
    print("Done.")

# This __name__ == "__main__" guard is essential for multiprocessing
if __name__ == "__main__":
    main()
