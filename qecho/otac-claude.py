# generated by claude leveraging the two pdf files in this repository

"""
PyQrack OTOC (Out-of-Time-Order Correlator) Simulation
Demonstrates quantum information scrambling using PyQrack's API
"""

import numpy as np
from pyqrack import QrackSimulator
import matplotlib.pyplot as plt


def create_ising_hamiltonian_circuit(num_qubits, J, h, time_step, trotter_steps):
    """
    Create a Trotterized circuit for the Transverse-Field Ising Model (TFIM).
    H = -J * sum(Z_i Z_(i+1)) - h * sum(X_i)
    
    Args:
        num_qubits: Number of qubits in the chain
        J: ZZ interaction strength
        h: Transverse field strength
        time_step: Time increment for evolution
        trotter_steps: Number of Trotter steps
    
    Returns:
        List of gate operations to apply
    """
    operations = []
    dt = time_step / trotter_steps
    
    for step in range(trotter_steps):
        # Apply transverse field terms: exp(-i * h * X_i * dt)
        for i in range(num_qubits):
            angle = 2 * h * dt
            operations.append(('rx', angle, i))
        
        # Apply ZZ interaction terms: exp(-i * J * Z_i Z_(i+1) * dt)
        for i in range(num_qubits - 1):
            angle = 2 * J * dt
            # Decompose ZZ rotation using CNOT gates
            operations.append(('cnot', i, i + 1))
            operations.append(('rz', angle, i + 1))
            operations.append(('cnot', i, i + 1))
    
    return operations


def apply_pauli_operator(sim, operator, qubit):
    """Apply a Pauli operator (X, Y, or Z) to a qubit."""
    if operator == 'X':
        sim.x(qubit)
    elif operator == 'Y':
        sim.y(qubit)
    elif operator == 'Z':
        sim.z(qubit)


def apply_operations(sim, operations):
    """Apply a list of operations to a simulator."""
    for op in operations:
        if op[0] == 'rx':
            # RX gate: rotation around X axis
            sim.r(1, op[1], op[2])  # Pauli basis 1 = X
        elif op[0] == 'rz':
            # RZ gate: rotation around Z axis
            sim.r(3, op[1], op[2])  # Pauli basis 3 = Z
        elif op[0] == 'cnot':
            sim.mcx([op[1]], op[2])


def build_otoc_circuit(num_qubits, measurement_qubit, butterfly_qubit, 
                       J, h, evolution_time, trotter_steps):
    """
    Build the full OTOC circuit: V, U(t), W, U dagger(t)
    
    The OTOC is defined as: F(t) = < W dagger(t) V dagger W(t) V >
    where W(t) = U dagger(t) W U(t) is the time-evolved operator
    
    Args:
        num_qubits: Number of qubits
        measurement_qubit: Index of the measurement qubit (V operator location)
        butterfly_qubit: Index of the butterfly qubit (W operator location)
        J: Ising coupling strength
        h: Transverse field strength
        evolution_time: Total evolution time
        trotter_steps: Number of Trotter steps for time evolution
    
    Returns:
        List of operations for OTOC measurement
    """
    operations = []
    
    # 1. Initial state preparation: Apply V (X on measurement qubit)
    operations.append(('pauli', 'X', measurement_qubit))
    
    # 2. Forward time evolution: U(t)
    forward_evolution = create_ising_hamiltonian_circuit(
        num_qubits, J, h, evolution_time, trotter_steps
    )
    operations.extend(forward_evolution)
    
    # 3. Apply butterfly operator W (X on butterfly qubit)
    operations.append(('pauli', 'X', butterfly_qubit))
    
    # 4. Backward time evolution: U dagger(t)
    # Create the inverse by reversing and conjugating
    backward_evolution = create_ising_hamiltonian_circuit(
        num_qubits, -J, -h, evolution_time, trotter_steps
    )
    operations.extend(backward_evolution)
    
    # 5. Apply V dagger and W dagger (both are X gates, which are self-inverse)
    operations.append(('pauli', 'X', butterfly_qubit))
    operations.append(('pauli', 'X', measurement_qubit))
    
    return operations


def calculate_otoc(num_qubits, measurement_qubit, butterfly_qubit,
                   J, h, evolution_time, trotter_steps, num_shots=1000):
    """
    Calculate the OTOC value by simulating the circuit and measuring.
    
    Returns:
        OTOC value (expectation value)
    """
    # Create simulator
    sim = QrackSimulator(num_qubits, isStabilizerHybrid=True)
    
    # Build OTOC operations
    operations = build_otoc_circuit(
        num_qubits, measurement_qubit, butterfly_qubit,
        J, h, evolution_time, trotter_steps
    )
    
    # Apply all operations
    for op in operations:
        if op[0] == 'pauli':
            apply_pauli_operator(sim, op[1], op[2])
        elif op[0] == 'rx':
            sim.r(1, op[1], op[2])  # Pauli basis 1 = X
        elif op[0] == 'rz':
            sim.r(3, op[1], op[2])  # Pauli basis 3 = Z
        elif op[0] == 'cnot':
            sim.mcx([op[1]], op[2])
    
    # Measure the measurement qubit
    # OTOC corresponds to probability of measuring |0 rangle
    prob_zero = sim.prob(measurement_qubit)
    
    # OTOC value (simplified): 2 * P(0) - 1
    # This maps probability [0,1] to [-1,1]
    otoc = 2 * prob_zero - 1
    
    return otoc


def simulate_otoc_decay(num_qubits=6, J=1.0, h=0.5, max_time=2.0, 
                        time_points=20, trotter_steps=10):
    """
    Simulate OTOC decay over time to observe information scrambling.
    
    Returns:
        times: Array of evolution times
        otoc_values: Array of corresponding OTOC values
    """
    measurement_qubit = 0  # First qubit
    butterfly_qubit = num_qubits // 2  # Middle qubit
    
    times = np.linspace(0.1, max_time, time_points)
    otoc_values = []
    
    print(f"Simulating OTOC for {num_qubits}-qubit Ising chain...")
    print(f"Parameters: J={J}, h={h}")
    print(f"Measurement qubit: {measurement_qubit}, Butterfly qubit: {butterfly_qubit}")
    
    for t in times:
        otoc = calculate_otoc(
            num_qubits, measurement_qubit, butterfly_qubit,
            J, h, t, trotter_steps
        )
        otoc_values.append(otoc)
        print(f"Time: {t:.3f}, OTOC: {otoc:.4f}")
    
    return times, np.array(otoc_values)


def plot_otoc_decay(times, otoc_values):
    """Plot the OTOC decay showing information scrambling."""
    plt.figure(figsize=(10, 6))
    plt.plot(times, otoc_values, 'o-', linewidth=2, markersize=6)
    plt.xlabel('Evolution Time', fontsize=12)
    plt.ylabel('OTOC Value', fontsize=12)
    plt.title('Quantum Information Scrambling: OTOC Decay', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.axhline(y=0, color='r', linestyle='--', alpha=0.5, label='Zero crossing')
    plt.legend()
    plt.tight_layout()
    plt.savefig('otoc_decay.png', dpi=150)
    print("Plot saved as 'otoc_decay.png'")
    plt.show()


def demonstrate_loschmidt_echo(num_qubits=6, J=1.0, h=0.5, 
                               evolution_time=1.0, trotter_steps=10):
    """
    Demonstrate Loschmidt Echo (without butterfly perturbation).
    This should ideally return to initial state (OTOC approximately 1).
    """
    print("\n--- Loschmidt Echo Demonstration ---")
    
    sim = QrackSimulator(num_qubits, isStabilizerHybrid=True)
    
    # Initial state preparation
    measurement_qubit = 0
    apply_pauli_operator(sim, 'X', measurement_qubit)
    
    # Forward evolution
    forward = create_ising_hamiltonian_circuit(
        num_qubits, J, h, evolution_time, trotter_steps
    )
    apply_operations(sim, forward)
    
    # Backward evolution (no butterfly operator)
    backward = create_ising_hamiltonian_circuit(
        num_qubits, -J, -h, evolution_time, trotter_steps
    )
    apply_operations(sim, backward)
    
    # Measure
    prob_zero = sim.prob(measurement_qubit)
    echo = 2 * prob_zero - 1
    
    print(f"Loschmidt Echo: {echo:.4f}")
    print(f"(Ideal value: 1.0, shows reversibility without perturbation)")
    
    return echo


if __name__ == "__main__":
    # Main simulation
    print("=" * 60)
    print("PyQrack OTOC Simulation: Quantum Information Scrambling")
    print("=" * 60)
    
    # Demonstrate Loschmidt Echo first
    demonstrate_loschmidt_echo(num_qubits=6, J=1.0, h=0.5)
    
    # Run OTOC simulation
    print("\n" + "=" * 60)
    times, otoc_values = simulate_otoc_decay(
        num_qubits=6,
        J=1.0,
        h=0.5,
        max_time=2.0,
        time_points=15,
        trotter_steps=10
    )
    
    # Plot results
    plot_otoc_decay(times, otoc_values)
    
    print("\n" + "=" * 60)
    print("Simulation complete!")
    print("OTOC decay demonstrates the quantum butterfly effect:")
    print("- Initial OTOC approximately 1: operators commute")
    print("- OTOC decays: information spreads/scrambles")
    print("- Final OTOC approximately 0: complete thermalization")
    print("=" * 60)
