#!/usr/bin/env python3
# graph for the output of otoc_validation_isingonly.sh
# generated by gemini25
# ... (previous comments) ...
# MESH FIX: Replaced point cloud with a 3D surface (Delaunay2D).
# WORKER FIX: Reverted num_workers to os.cpu_count().
# IO BOTTLENECK FIX: Removed print() from parallel loop, added summary.

import re
import ast
import pandas as pd
from vedo import Points, Plotter, settings # Import settings
from pathlib import Path
# import math # No longer needed
import concurrent.futures  # For ProcessPoolExecutor
import os                  # To get CPU count

# --- Configuration ---
LOG_DIR = "otoc_sweep_log"
OUTPUT_FILE = "otoc_sweep_3d_plot.png"
# --- End Configuration ---

def parse_log_file(file_path):
    # This function is unchanged and correct
    match = re.search(r"q(\d+)_d(\d+)\.log", file_path.name)
    if not match:
        return None
    qubits = int(match.group(1))
    depth = int(match.group(2))
    time_match = None
    prob_zero = None
    found_header = False 
    in_dict = False      
    brace_level = 0
    prob_regex = re.compile(r"\b0:\s*([\d\.eE+-]+)")

    try:
        with file_path.open('r') as f:
            for line in f:
                time_search = re.search(r"real\s+(\d+)m([\d\.]+)s", line)
                if time_search:
                    time_match = time_search
                
                if not found_header:
                    if "PyQrackIsing Probabilities:" in line:
                        found_header = True
                        start_match = re.search(r"(\{)", line)
                        if start_match:
                            in_dict = True
                            brace_level += line.count('{') - line.count('}')
                            if prob_zero is None:
                                prob_match = prob_regex.search(line)
                                if prob_match:
                                    prob_zero = float(prob_match.group(1))
                
                elif found_header and not in_dict:
                    start_match = re.search(r"(\{)", line)
                    if start_match:
                        in_dict = True
                        brace_level += line.count('{') - line.count('}')
                        if prob_zero is None:
                            prob_match = prob_regex.search(line)
                            if prob_match:
                                prob_zero = float(prob_match.group(1))
                
                elif in_dict:
                    if prob_zero is None:
                        prob_match = prob_regex.search(line)
                        if prob_match:
                            prob_zero = float(prob_match.group(1))
                    brace_level += line.count('{') - line.count('}')
                    if brace_level == 0:
                        in_dict = False
                        
        if not time_match:
            # This print is fine, it should be rare
            print(f"Warning: Could not find 'real' time string in {file_path.name}")
            return None
        try:
            minutes = float(time_match.group(1))
            seconds = float(time_match.group(2))
            total_seconds = (minutes * 60) + seconds
        except (ValueError, TypeError) as e:
            print(f"Error converting time string in {file_path.name}: {e}")
            return None

        if total_seconds <= 0:
            print(f"Warning: Non-positive time {total_seconds}s in {file_path.name}")
            return None
            
        if in_dict:
            print(f"Warning: Reached EOF, but dict was still open in {file_path.name}")
        if not found_header:
            print(f"Warning: Could not find results dict header in {file_path.name}")
            return None
        
        # --- I/O BOTTLENECK FIX ---
        key_0_missing = False
        if prob_zero is None:
            # print(f"Warning: Key '0' not found in {file_path.name}. Defaulting to 0.0") # <-- SILENCED
            prob_zero = 0.0
            key_0_missing = True
        # --- END FIX ---

        return {
            "qubits": qubits, 
            "depth": depth, 
            "time": total_seconds,
            "prob_zero": prob_zero,
            "key_0_missing": key_0_missing # <-- Return the warning flag
        }
        
    except Exception as e:
        print(f"Error processing {file_path.name}: {e}")
        return None


def main():
    log_path = Path(LOG_DIR)
    if not log_path.is_dir():
        print(f"Error: Log directory '{LOG_DIR}' not found.")
        return

    print(f"Scanning {LOG_DIR} for log files...")
    log_files = list(log_path.glob("q*_d*.log"))
    if not log_files:
        print(f"Error: No log files found in '{LOG_DIR}'.")
        return

    # --- Multiprocessing ---
    
    # --- WORKER COUNT FIX: Reverted to optimal count ---
    num_workers = os.cpu_count()
    # --- END FIX ---
    
    print(f"Parsing {len(log_files)} log files using up to {num_workers} processes...")
    
    # --- I/O BOTTLENECK FIX: Collect results and print summary ---
    results_list = []
    key_0_warnings = 0
    with concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:
        results_iterator = executor.map(parse_log_file, log_files)
        # Iterate to collect results and warnings
        for result in results_iterator:
            if result is not None:
                results_list.append(result)
                if result["key_0_missing"]:
                    key_0_warnings += 1

    if not results_list:
        print("Error: No data could be parsed from log files.")
        return
        
    print(f"Successfully parsed {len(results_list)} log files.")
    
    # Print ONE summary line for all warnings
    if key_0_warnings > 0:
        print(f"INFO: {key_0_warnings} log files were missing the '0' key and defaulted to prob_zero=0.0")
    # --- END FIX ---


    # 3. Create Pandas DataFrame
    df = pd.DataFrame(results_list)

    # --- Apply 10x scaling to the time axis ---
    df['scaled_time'] = df['time'] * 10.0
    
    df = df.sort_values(by=["qubits", "depth"])

    # --- DIAGNOSTIC STEP ---
    print("\n--- Data Summary ---")
    print(df.describe())
    print("--------------------\n")
    
    if df.empty or df[['qubits', 'depth', 'scaled_time']].isnull().values.any(): 
        print("Error: Data is empty or contains invalid (NaN) coordinates. Cannot plot.")
        return
        
    # --- GET MAX TIME FOR Z-AXIS RANGE ---
    max_scaled_time = df['scaled_time'].max() 

    print("Generating 3D interactive plot...")

    # --- Vedo Plotting Logic ---
    coords = df[['qubits', 'depth', 'scaled_time']].values
    scalars = df['prob_zero'].values
    
    # 1. Create the Points object (in memory, not for display)
    pts = Points(coords)
    pts.pointdata["prob_zero"] = scalars
    
    # --- NEW FIX: Create a 3D surface mesh ---
    print("Generating 2D Delaunay triangulation (creating surface)...")
    mesh = pts.delaunay2D()
    
    mesh.cmap("viridis", "prob_zero") 
    mesh.alpha(1.0) 
    mesh.add_scalarbar(title="Probability of '0' State", pos=((0.85, 0.1), (0.9, 0.9)), c='white')
    # --- END NEW FIX ---


    # 5. Create a Plotter instance
    plt = Plotter(
        title="OTOC Sweep: Time vs. Qubits and Depth",  
        bg='black',
        axes={
            'xtitle': 'Number of Qubits',
            'ytitle': 'Depth',
            'ztitle': 'Scaled Execution Time (s) [10x]',
            'c': 'white',
            'zrange': (0, max_scaled_time) 
        }
    )
    
    # --- CHANGED: Add the mesh, not the points ---
    plt.add(mesh)
    # --- END CHANGED ---

    # 8. Show the interactive window
    print("Displaying plot in separate window...")
    print("NOTE: The screenshot will be saved *after* you close this window.")
    
    plt.show(zoom=1.0)
    
    # 7. Save to PNG
    try:
        print(f"Attempting to save screenshot to: {OUTPUT_FILE}...")
        plt.screenshot(OUTPUT_FILE)
        print(f"Successfully saved screenshot to: {OUTPUT_FILE}")
    except Exception as e:
        print(f"Could not save screenshot: {e}")

    print("Done.")


if __name__ == "__main__":
    main()
